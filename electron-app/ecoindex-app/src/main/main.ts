import {
  BrowserWindow,
  IpcMainEvent,
  Notification,
  app,
  dialog,
  ipcMain,
} from 'electron'
import { ChildProcess, fork, spawn } from 'child_process'
import { channels, utils } from '../shared/constants'
import { chomp, chunksToLinesAsync } from '@rauschma/stringio'

import fixPath from 'fix-path'
import fs from 'fs'
import os from 'os'
import packageJson from '../../package.json'
import { shellEnv } from 'shell-env'
import shelljs from 'shelljs'

// const execFile = util.promisify(_execFile);

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

let workDir = ''

const runfixPath = () => {
  console.log(`RUN fixPath and shellEnv`)
  fixPath()
  const { shell } = os.userInfo()
  console.log(`shell`, shell)
  console.log('shelljs.config.execPath', shelljs.config.execPath) // return null
  shelljs.config.execPath = shell
  console.log('shelljs.config.execPath', shelljs.config.execPath) // return null
}

runfixPath()

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit()
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
    },
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  mainWindow.webContents.openDevTools({ mode: 'detach' })
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // simple handlers
  ipcMain.handle(channels.SIMPLE_MESURES, handleSimpleCollect)
  // json handlers
  ipcMain.handle(channels.SAVE_JSON_FILE, handleJsonSaveAndCollect)
  ipcMain.handle(channels.READ_RELOAD_JSON_FILE, handleJsonReadAndReload)
  // communs handlers and getters
  ipcMain.handle(channels.GET_NODE_VERSION, getNodeVersion)
  ipcMain.handle(channels.SELECT_FOLDER, handleSelectFolder)
  ipcMain.handle(channels.GET_WORKDIR, handleWorkDir)
  ipcMain.handle(
    channels.IS_LIGHTHOUSE_ECOINDEX_INSTALLED,
    handlePluginInstalled,
  )
  ipcMain.handle(channels.IS_NODE_INSTALLED, handleNodeInstalled)
  ipcMain.handle(
    channels.IS_JSON_CONFIG_FILE_EXIST,
    handleIsJsonConfigFileExist,
  )
  ipcMain.handle(
    channels.INSTALL_ECOINDEX_PLUGIN,
    handleLighthouseEcoindexPluginInstall,
  )
  app.setAboutPanelOptions({
    applicationName: packageJson.productName,
    applicationVersion: packageJson.name,
    version: packageJson.version,
    credits: packageJson.description,
    copyright: packageJson.publisher,
  })
  // showNotification()
  _createWindow()
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// #region Helpers

async function _echoReadable(event: IpcMainEvent, readable: any) {
  const webContents = event.sender
  const win = BrowserWindow.fromWebContents(webContents)
  for await (const line of chunksToLinesAsync(readable)) {
    // (C)
    console.log('> ' + chomp(line))
    // ipcRenderer.send('chomp', line);
    // i want to send to front the content of the line
    // I want to listen echo from main.ts and display it in the p tag without removing the previous content
    win.webContents.send(channels.ASYNCHRONOUS_LOG, chomp(line))
  }
}

let mainWindow: BrowserWindow = null
const _createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 800,
    icon: '/assets/app-ico.png',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  // mainWindow.webContents.openDevTools({ mode: 'detach' })
}

const _sendMessageToFrontLog = (message?: any, ...optionalParams: any[]) => {
  mainWindow.webContents.send(
    channels.HOST_INFORMATIONS,
    message,
    optionalParams,
  )
}

let logStream: fs.WriteStream = null
async function _sendMessageToBackLog(message?: any, ...optionalParams: any[]) {
  if (!workDir) {
    workDir = await _getHomeDir()
  }
  const logFilePath = `${workDir}/logfile.txt`
  if (!logStream) {
    logStream = fs.createWriteStream(logFilePath)
    logStream.write(' ')
  }

  logStream.write(message + ' ' + optionalParams.map(str => str) + '\n')
}

const _getHomeDir = async () => {
  // fixPath()
  const _shellEnv = await shellEnv()
  const home = _shellEnv.HOME
  if (!home) {
    _sendMessageToFrontLog('ERROR', 'Home dir not found in PATH', _shellEnv)
    throw new Error('Home dir not found in PATH')
  }
  return home
}

const _getNodeVersion = async () => {
  // fixPath()
  const _shellEnv = await shellEnv()
  const nodeDir =
    _shellEnv.NODE || _shellEnv.NVM_BIN || _shellEnv.npm_node_execpath
  const nodeVersion = nodeDir?.match(/v\d+\.\d+\.\d+/)?.[0]
  if (!nodeVersion) {
    _sendMessageToFrontLog('ERROR', 'Node dir not found in PATH', _shellEnv)
    throw new Error('Node version not found in PATH')
  }
  return nodeVersion
}

const _getNodeDir = async () => {
  // fixPath()
  const _shellEnv = await shellEnv()
  // console.log(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`);
  const nodeDir =
    _shellEnv.NODE || _shellEnv.NVM_BIN || _shellEnv.npm_node_execpath
  if (!nodeDir) {
    _sendMessageToFrontLog('ERROR', 'Node dir not found in PATH', _shellEnv)
    throw new Error('Node dir not found in PATH')
  }
  // console.log(`Node dir: ${nodeDir}`);
  return nodeDir
}

const _getNpmDir = async () => {
  // fixPath()
  const _shellEnv = await shellEnv()
  // console.log(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`);

  const npmBinDir = _shellEnv.NVM_BIN || _shellEnv.npm_config_prefix + '/bin'
  if (!npmBinDir) {
    _sendMessageToFrontLog('ERROR', 'Npm dir not found in PATH', _shellEnv)
    throw new Error('Npm dir not found in PATH')
  }
  const updatedNpmBinDir = npmBinDir?.replace(/\/bin$/, '')
  // console.log(`Npm dir: ${npmDir}`);
  // console.log(`Updated npm dir: ${updatedNpmBinDir}`);

  return updatedNpmBinDir + '/lib/node_modules'
}

const _isDev = () => {
  return process.env['WEBPACK_SERVE'] === 'true'
}

// #endregion

// #region Public API - handleRunFakeMesure, handleSetTitle, handleWorkDir, handlePluginInstalled, handleNodeInstalled

const handleNodeInstalled = async (event: IpcMainEvent) => {
  const nodeDir = await _getNodeDir()
  try {
    fs.accessSync(nodeDir, fs.constants.F_OK)
    return true
  } catch (error) {
    return false
  }
}

const handlePluginInstalled = async (event: IpcMainEvent) => {
  const npmDir = await _getNpmDir()
  const pluginDir = `${npmDir}/lighthouse-plugin-ecoindex`
  try {
    fs.accessSync(pluginDir, fs.constants.F_OK)
    return true
  } catch (error) {
    return false
  }
}

const handleWorkDir = async (event: IpcMainEvent, newDir: string) => {
  // console.log(`newDir`, newDir)
  if (newDir) {
    logStream = null
    console.log(`Reset logStream`)

    workDir = newDir
  } else {
    workDir = await _getHomeDir()
  }
  // console.log(`workDir: ${workDir}`)
  return await workDir
}

const handleIsJsonConfigFileExist = async (
  event: IpcMainEvent,
  workDir: string,
) => {
  if (workDir === 'chargement...' || workDir === 'loading...') return
  const jsonConfigFile = `${workDir}/${utils.JSON_FILE_NAME}`
  console.log(`handleIsJsonConfigFileExist`, jsonConfigFile)
  try {
    fs.accessSync(jsonConfigFile, fs.constants.F_OK)
    showNotification({
      body: 'Config file founded ðŸ‘€',
      subtitle: 'loading file content...',
    })
    return true
  } catch (error) {
    return false
  }
}

async function _prepareJsonCollect(): Promise<{
  logStream: fs.WriteStream
  command: string[]
  nodeDir: string
  workDir: string
}> {
  // create stream to log the output. TODO: use specified path
  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    // console.log(`Work dir: ${_workDir}`)
    // const logFilePath = `${_workDir}/logfile.txt`
    // const logStream = fs.createWriteStream(logFilePath)

    const _shellEnv = await shellEnv()
    _sendMessageToBackLog(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`)

    const nodeDir = await _getNodeDir()
    _sendMessageToBackLog(`Node dir: ${nodeDir}`)
    console.log(`Node dir: ${nodeDir}`)

    const npmDir = await _getNpmDir()
    _sendMessageToBackLog(`Npm dir: ${npmDir}`)
    console.log(`Npm dir: ${npmDir}`)

    const command = [
      `${npmDir}/lighthouse-plugin-ecoindex/cli/index.js`,
      'collect',
    ]
    return { logStream, command, nodeDir, workDir: _workDir }
  } catch (error) {
    console.error('Error', error)
  }
}

async function _runCollect(
  command: string[],
  nodeDir: string,
  event: IpcMainEvent,
  logStream: fs.WriteStream,
): Promise<string> {
  _sendMessageToBackLog(
    `runCollect: ${nodeDir} ${JSON.stringify(command, null, 2)}`,
  )
  const controller = new AbortController()
  const { signal } = controller
  const childProcess: ChildProcess = spawn(`${nodeDir}`, command, {
    stdio: ['pipe', 'pipe', process.stderr],
    shell: true,
    signal,
  })

  childProcess.on('exit', (code, signal) => {
    _sendMessageToBackLog(
      `Child process exited with code ${code} and signal ${signal}`,
    )
  })

  childProcess.on('close', code => {
    _sendMessageToBackLog(`Child process close with code ${code}`)
    _sendMessageToBackLog('Mesure done ðŸš€')
  })

  childProcess.stdout.on('data', data => {
    _sendMessageToBackLog(`stdout: ${data}`)
  })

  if (childProcess.stderr) {
    childProcess.stderr.on('data', data => {
      _sendMessageToBackLog(`stderr: ${data.toString()}`)
    })
  }

  childProcess.on('disconnect', () => {
    _sendMessageToBackLog('Child process disconnected')
  })

  childProcess.on('message', (message, sendHandle) => {
    _sendMessageToBackLog(`Child process message: ${message}`)
  })

  await _echoReadable(event, childProcess.stdout)
  controller.abort()
  return 'mesure done'
}

async function handleSimpleCollect(
  event: IpcMainEvent,
  urlsList: SimpleUrlInput[],
) {
  if (!urlsList || urlsList.length === 0) {
    throw new Error('Urls list is empty')
  }
  showNotification({
    subtitle: 'ðŸ§© Simple collect',
    body: 'Process intialization.',
  })

  const {
    command,
    logStream,
    nodeDir,
    workDir: _workDir,
  } = await _prepareJsonCollect()
  console.log('Simple mesure start, process intialization...')
  _sendMessageToBackLog('Simple mesure start, process intialization...')
  console.log(`Urls list: ${JSON.stringify(urlsList)}`)
  _sendMessageToBackLog(`Urls list: ${JSON.stringify(urlsList)}`)
  try {
    urlsList.forEach(url => {
      if (url.value) {
        command.push('-u')
        command.push(url.value)
      }
    })
    command.push('-o')
    command.push('html')
    command.push('--output-path')
    command.push(_workDir)
    // Fake mesure and path. TODO: use specified path and urls
    showNotification({
      subtitle: ' ðŸš€Simple collect',
      body: 'Collect started...',
    })
    try {
      await _runCollect(command, nodeDir, event, logStream)
    } catch (error) {
      showNotification({
        subtitle: 'ðŸš« Simple collect',
        body: `Collect KO, ${error}\n'`,
      })
      throw new Error('Simple collect error')
    }
    // process.stdout.write(data)
    // console.log(result.stdout.toString());
    showNotification({
      subtitle: 'ðŸŽ‰ Simple collect',
      body: `Collect done, you can consult reports in\n${_workDir}'`,
    })
    console.log('Simple collect done ðŸš€')
    return 'collect done'
  } catch (error) {
    _sendMessageToBackLog(`stderr: ${error}`)
  }
  // alert process done
}

/**
 * SimpleUrlInput[] -> string[]
 * @param jsonDatas with urls SimpleUrlInput[]
 */
const _convertJSONDatasFromSimpleUrlInput = (
  jsonDatas: IJsonMesureData,
): IJsonMesureData => {
  const output = jsonDatas
  jsonDatas.courses.forEach((course, index) => {
    const urls: string[] = course.urls.map((url: any) => url.value)
    jsonDatas.courses[index].urls = urls
  })
  return output
}
/**
 * string[] -> SimpleUrlInput[]
 * @param jsonDatas with urls string[]
 */
const _convertJSONDatasFromString = (
  jsonDatas: IJsonMesureData,
): IJsonMesureData => {
  const output = jsonDatas
  jsonDatas.courses.forEach((course, index) => {
    const urls: SimpleUrlInput[] = course.urls.map((url: any) => {
      return {
        value: url,
      }
    })
    jsonDatas.courses[index].urls = urls
  })
  // console.log(`_convertJSONDatasFromString`, output)
  return output
}

const handleJsonSaveAndCollect = async (
  event: IpcMainEvent,
  jsonDatas: IJsonMesureData,
  andCollect: boolean,
) => {
  if (!jsonDatas) {
    throw new Error('Json data is empty')
  }
  showNotification({
    subtitle: andCollect ? 'ðŸ§© JSON save and collect' : 'ðŸ§© JSON save',
    body: 'Process intialization.',
  })
  console.log('Json save or/and collect start...')
  _sendMessageToBackLog('Json save or/and collect start...')

  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    console.log(`Work dir: ${_workDir}`)
    const jsonFilePath = `${_workDir}/${utils.JSON_FILE_NAME}`
    const jsonStream = fs.createWriteStream(jsonFilePath)
    if ((jsonDatas['extra-header'], jsonDatas['extra-header'])) {
      try {
        console.log(`extra-header`, jsonDatas['extra-header'])
        if (typeof jsonDatas['extra-header'] === 'object') {
          jsonDatas['extra-header'] = Object(
            String(jsonDatas['extra-header']).replace(/\\/g, ''),
          )
        } else {
          jsonDatas['extra-header'] = JSON.parse(
            String(jsonDatas['extra-header']).replace(/\\/g, ''),
          )
        }
      } catch (error) {
        throw new Error(`extra-header is not in Json format. ${error}`)
      }
    }
    showNotification({
      subtitle: andCollect ? 'ðŸš€ JSON save and collect' : 'ðŸš€ JSON save',
      body: andCollect
        ? 'Json save and collect started...'
        : 'Json save started...',
    })
    try {
      if (jsonDatas && typeof jsonDatas === 'object') {
        jsonStream.write(
          JSON.stringify(
            _convertJSONDatasFromSimpleUrlInput(jsonDatas),
            null,
            2,
          ),
        )
      } else {
        throw new Error('jsonDatas have a problem!')
      }
    } catch (error) {
      showNotification({
        subtitle: andCollect ? 'ðŸš« JSON save and collect' : 'ðŸš« JSON save',
        body: 'Json file not saved.',
      })
      _sendMessageToBackLog(`Error writing JSON file. ${error}`)
      throw new Error(`Error writing JSON file. ${error}`)
    }
    if (!andCollect) {
      showNotification({
        subtitle: 'ðŸ’¾ JSON save',
        body: 'Json file saved.',
      })
    } else {
      console.log('Json mesure start...')

      const {
        command,
        logStream,
        nodeDir,
        workDir: _workDir,
      } = await _prepareJsonCollect()
      _sendMessageToBackLog('Json mesure start...')
      _sendMessageToBackLog(`JSON datas ${JSON.stringify(jsonDatas, null, 2)}`)
      command.push('--json-file')
      command.push(_workDir + '/' + utils.JSON_FILE_NAME)
      command.push('--output-path')
      command.push(_workDir)
      try {
        await _runCollect(command, nodeDir, event, logStream)
      } catch (error) {
        throw new Error('Simple collect error')
      }
      showNotification({
        subtitle: 'ðŸŽ‰ JSON collect',
        body: `Mesures done, you can consult reports in\n${_workDir}`,
      })
      _sendMessageToBackLog('Json collect done ðŸš€')
      console.log('Json collect done ðŸš€')
      return 'mesure done'
    }
  } catch (error) {
    if (!andCollect) {
      _sendMessageToFrontLog('ERROR, Json file not saved', error)
      showNotification({
        subtitle: 'ðŸš« JSON save',
        body: 'Json file not saved.',
      })
    } else {
      _sendMessageToFrontLog('ERROR, Json file not saved or collect', error)
      showNotification({
        subtitle: 'ðŸš« JSON save and collect',
        body: 'Json file not saved or collect.',
      })
    }
  }
}

const handleJsonReadAndReload = async (event: IpcMainEvent) => {
  showNotification({
    subtitle: 'ðŸ§© JSON reload',
    body: 'Process intialization.',
  })
  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    // console.log(`Work dir: ${_workDir}`)
    const jsonFilePath = `${_workDir}/${utils.JSON_FILE_NAME}`
    return new Promise((resolve, reject) => {
      const jsonStream = fs.createReadStream(jsonFilePath)
      jsonStream.on('data', function (chunk) {
        const jsonDatas = JSON.parse(chunk.toString())
        console.log(`jsonDatas`, jsonDatas)

        showNotification({
          subtitle: 'ðŸ”„ JSON reload',
          body: 'Json file read and reloaded.',
        })
        resolve(_convertJSONDatasFromString(jsonDatas) as IJsonMesureData)
      })
    })
  } catch (error) {
    _sendMessageToFrontLog('ERROR', 'Json file not read and reloaded', error)
    showNotification({
      subtitle: 'ðŸš« JSON reload',
      body: `Json file not read and reloaded. ${error}`,
    })
    // throw new Error(`Json file not read and reloaded. ${error}`)
  }
}

async function handleLighthouseEcoindexPluginInstall(event: IpcMainEvent) {
  console.log(`handleLighthouseEcoindexPluginInstall`)
  _sendMessageToBackLog(`handleLighthouseEcoindexPluginInstall started ðŸš€`)

  const _shellEnv = await shellEnv()
  _sendMessageToBackLog(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`)

  const nodeDir = await _getNodeDir()
  _sendMessageToBackLog(`Node dir: ${nodeDir}`)
  console.log(`Node dir: ${nodeDir}`)

  const npmDir = await _getNpmDir()
  const [nmpRun] = npmDir.split('lib')
  _sendMessageToBackLog(`Npm dir: ${npmDir}`)
  _sendMessageToBackLog(`Npm runner: ${nmpRun}bin/npm`)
  console.log(`Npm dir: ${npmDir}`)
  console.log(`Npm runner: ${nmpRun}bin/npm`)
  const controller = new AbortController()
  const { signal } = controller
  // const command = [`${__dirname}/install-plugin.sh`]
  const command = ['i', '-g', 'lighthouse-plugin-ecoindex']

  // if (!shelljs.which('node')) {
  //   shelljs.echo('Sorry, this script requires node')
  //   shelljs.exit(1)
  // } else {
  //   console.log(`shelljs.which('npm')`, shelljs.which('npm'))
  // }
  const { shell } = os.userInfo()
  const env = {
    ...process.env,
    PATH: `${process.env.PATH}:/usr/local/bin:/${shell}`,
  }
  // shelljs.config.execPath = nodeDir
  console.log(`shelljs.config.execPath`, shelljs.config.execPath)

  if (!shelljs.which('node')) {
    shelljs.echo('Sorry, this script requires node')
    shelljs.exit(1)
  }
  try {
    shelljs.exec('npm i -g lighthouse-plugin-ecoindex')
  } catch (error) {
    console.error(error)
  }
  process.noAsar = true
  const childProcess: ChildProcess = spawn(`npm`, command, {
    stdio: ['pipe', 'pipe', process.stderr, 'ipc'],
    env: env,
    // signal,
    shell: true,
  })
  // const childProcess: ChildProcess = spawn('ls', ['-lh', __dirname])

  childProcess.on('exit', (code, signal) => {
    _sendMessageToBackLog(
      `Child process exited with code ${code} and signal ${signal}`,
    )
  })

  childProcess.on('close', code => {
    _sendMessageToBackLog(`Child process close with code ${code}`)
    _sendMessageToBackLog('Installation done ðŸš€')
  })

  childProcess.stdout.on('data', data => {
    _sendMessageToBackLog(`stdout: ${data}`)
  })

  if (childProcess.stderr) {
    childProcess.stderr.on('data', data => {
      _sendMessageToBackLog(`stderr: ${data.toString()}`)
    })
  }

  childProcess.on('disconnect', () => {
    _sendMessageToBackLog('Child process disconnected')
  })

  childProcess.on('message', (message, sendHandle) => {
    _sendMessageToBackLog(`Child process message: ${message}`)
  })

  await _echoReadable(event, childProcess.stdout)
  controller.abort()
  return 'Installation done'
}

async function handleSelectFolder() {
  const options: Electron.OpenDialogOptions = {
    properties: ['openDirectory', 'createDirectory'],
  }
  const { canceled, filePaths } = await dialog.showOpenDialog(options)
  if (!canceled) {
    workDir = filePaths[0]
    return filePaths[0]
  }
}

async function getNodeVersion() {
  return await _getNodeVersion()
}

function showNotification(options: any) {
  if (!options) {
    options = {
      body: 'Notification body',
      subtitle: 'Notification subtitle',
    }
  }
  if (!options.title || options.title === '') {
    options.title = packageJson.productName
  }
  const customNotification = new Notification(options)
  customNotification.show()
}

// #endregion
