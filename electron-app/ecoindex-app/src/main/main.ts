import {
  BrowserWindow,
  IpcMainEvent,
  Notification,
  app,
  dialog,
  ipcMain,
} from 'electron'
import { ChildProcess, spawn } from 'child_process'
import { channels, utils } from '../shared/constants'
import { chomp, chunksToLinesAsync } from '@rauschma/stringio'

import fixPath from 'fix-path'
import fs from 'fs'
import packageJson from '../../package.json'
import { shellEnv } from 'shell-env'

// const execFile = util.promisify(_execFile);

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

let workDir = ''

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit()
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
    },
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  mainWindow.webContents.openDevTools({ mode: 'detach' })
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // simple handlers
  ipcMain.handle(channels.SIMPLE_MESURES, handleSimpleCollect)
  // json handlers
  ipcMain.handle(channels.SAVE_JSON_FILE, handleJsonSaveAndCollect)
  ipcMain.handle(channels.READ_RELOAD_JSON_FILE, handleJsonReadAndReload)
  // communs handlers and getters
  ipcMain.handle(channels.GET_NODE_VERSION, getNodeVersion)
  ipcMain.handle(channels.SELECT_FOLDER, handleSelectFolder)
  ipcMain.handle(channels.GET_WORKDIR, handleWorkDir)
  ipcMain.handle(
    channels.IS_LIGHTHOUSE_ECOINDEX_INSTALLED,
    handlePluginInstalled,
  )
  ipcMain.handle(channels.IS_NODE_INSTALLED, handleNodeInstalled)
  ipcMain.handle(
    channels.IS_JSON_CONFIG_FILE_EXIST,
    handleIsJsonConfigFileExist,
  )
  app.setAboutPanelOptions({
    applicationName: packageJson.productName,
    applicationVersion: packageJson.name,
    version: packageJson.version,
    credits: packageJson.description,
    copyright: packageJson.publisher,
  })
  // showNotification()
  _createWindow()
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// #region Helpers
async function _echoReadable(event: IpcMainEvent, readable: any) {
  const webContents = event.sender
  const win = BrowserWindow.fromWebContents(webContents)
  for await (const line of chunksToLinesAsync(readable)) {
    // (C)
    console.log('> ' + chomp(line))
    // ipcRenderer.send('chomp', line);
    // i want to send to front the content of the line
    // I want to listen echo from main.ts and display it in the p tag without removing the previous content
    win.webContents.send(channels.ASYNCHRONOUS_LOG, chomp(line))
  }
}

let mainWindow: BrowserWindow = null
const _createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 1000,
    height: 800,
    icon: '/assets/app-ico.png',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  // mainWindow.webContents.openDevTools({ mode: 'detach' })
}

const _sendMessageToFrontLog = (message?: any, ...optionalParams: any[]) => {
  mainWindow.webContents.send(
    channels.HOST_INFORMATIONS,
    message,
    optionalParams,
  )
}

const _getHomeDir = async () => {
  fixPath()
  const _shellEnv = await shellEnv()
  const home = _shellEnv.HOME
  if (!home) {
    _sendMessageToFrontLog('ERROR', 'Home dir not found in PATH', _shellEnv)
    throw new Error('Home dir not found in PATH')
  }
  return home
}

const _getNodeVersion = async () => {
  fixPath()
  const _shellEnv = await shellEnv()
  const nodeDir =
    _shellEnv.NODE || _shellEnv.NVM_BIN || _shellEnv.npm_node_execpath
  const nodeVersion = nodeDir?.match(/v\d+\.\d+\.\d+/)?.[0]
  if (!nodeVersion) {
    _sendMessageToFrontLog('ERROR', 'Node dir not found in PATH', _shellEnv)
    throw new Error('Node version not found in PATH')
  }
  return nodeVersion
}

const _getNodeDir = async () => {
  fixPath()
  const _shellEnv = await shellEnv()
  // console.log(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`);
  const nodeDir =
    _shellEnv.NODE || _shellEnv.NVM_BIN || _shellEnv.npm_node_execpath
  if (!nodeDir) {
    _sendMessageToFrontLog('ERROR', 'Node dir not found in PATH', _shellEnv)
    throw new Error('Node dir not found in PATH')
  }
  // console.log(`Node dir: ${nodeDir}`);
  return nodeDir
}

const _getNpmDir = async () => {
  fixPath()
  const _shellEnv = await shellEnv()
  // console.log(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}`);

  const npmBinDir = _shellEnv.NVM_BIN || _shellEnv.npm_config_prefix + '/bin'
  if (!npmBinDir) {
    _sendMessageToFrontLog('ERROR', 'Npm dir not found in PATH', _shellEnv)
    throw new Error('Npm dir not found in PATH')
  }
  const updatedNpmBinDir = npmBinDir?.replace(/\/bin$/, '')
  // console.log(`Npm dir: ${npmDir}`);
  // console.log(`Updated npm dir: ${updatedNpmBinDir}`);

  return updatedNpmBinDir + '/lib/node_modules'
}

const _isDev = () => {
  return process.env['WEBPACK_SERVE'] === 'true'
}

// #endregion

// #region Public API - handleRunFakeMesure, handleSetTitle, handleWorkDir, handlePluginInstalled, handleNodeInstalled

const handleNodeInstalled = async (event: IpcMainEvent) => {
  const nodeDir = await _getNodeDir()
  try {
    fs.accessSync(nodeDir, fs.constants.F_OK)
    return true
  } catch (error) {
    return false
  }
}

const handlePluginInstalled = async (event: IpcMainEvent) => {
  const npmDir = await _getNpmDir()
  const pluginDir = `${npmDir}/lighthouse-plugin-ecoindex`
  try {
    fs.accessSync(pluginDir, fs.constants.F_OK)
    return true
  } catch (error) {
    return false
  }
}

const handleWorkDir = async (event: IpcMainEvent, newDir: string) => {
  if (newDir) {
    workDir = newDir
  } else {
    workDir = await _getHomeDir()
  }
  // console.log(`workDir: ${workDir}`)
  return await workDir
}

const handleIsJsonConfigFileExist = async (
  event: IpcMainEvent,
  workDir: string,
) => {
  if (workDir === 'chargement...' || workDir === 'loading...') return
  const jsonConfigFile = `${workDir}/${utils.JSON_FILE_NAME}`
  console.log(`handleIsJsonConfigFileExist`, jsonConfigFile)
  try {
    fs.accessSync(jsonConfigFile, fs.constants.F_OK)
    showNotification({
      body: 'Config file founded 👀',
      subtitle: 'loading file content...',
    })
    return true
  } catch (error) {
    return false
  }
}

async function prepareJsonCollect(): Promise<{
  logStream: fs.WriteStream
  command: string[]
  nodeDir: string
  workDir: string
}> {
  // create stream to log the output. TODO: use specified path
  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    console.log(`Work dir: ${_workDir}`)
    const logFilePath = `${_workDir}/logfile.txt`
    const logStream = fs.createWriteStream(logFilePath)

    const _shellEnv = await shellEnv()
    logStream.write(`Shell Env: ${JSON.stringify(_shellEnv, null, 2)}\n`)

    const nodeDir = await _getNodeDir()
    logStream.write(`Node dir: ${nodeDir}\n`)
    console.log(`Node dir: ${nodeDir}`)

    const npmDir = await _getNpmDir()
    logStream.write(`Npm dir: ${npmDir}\n`)
    console.log(`Npm dir: ${npmDir}`)

    const command = [
      `${npmDir}/lighthouse-plugin-ecoindex/cli/index.js`,
      'collect',
    ]
    return { logStream, command, nodeDir, workDir: _workDir }
  } catch (error) {
    console.error('Error', error)
  }
}

async function runJsonCollect(
  command: string[],
  nodeDir: string,
  event: IpcMainEvent,
  logStream: fs.WriteStream,
): Promise<string> {
  const childProcess: ChildProcess = spawn(`${nodeDir}`, command, {
    stdio: ['pipe', 'pipe', process.stderr],
    shell: true,
  })

  childProcess.on('exit', (code, signal) => {
    logStream.write(
      `Child process exited with code ${code} and signal ${signal}\n`,
    )
  })

  childProcess.on('close', code => {
    logStream.write(`Child process close with code ${code}\n`)
    logStream.write('Mesure done 🚀\n')
  })

  childProcess.stdout.on('data', data => {
    logStream.write(`stdout: ${data}\n`)
  })

  if (childProcess.stderr) {
    childProcess.stderr.on('data', data => {
      logStream.write(`stderr: ${data.toString()}\n`)
    })
  }

  childProcess.on('disconnect', () => {
    logStream.write('Child process disconnected\n')
  })

  childProcess.on('message', (message, sendHandle) => {
    logStream.write(`Child process message: ${message}\n`)
  })

  await _echoReadable(event, childProcess.stdout)
  return 'mesure done'
}

async function handleSimpleCollect(
  event: IpcMainEvent,
  urlsList: SimpleUrlInput[],
) {
  if (!urlsList || urlsList.length === 0) {
    throw new Error('Urls list is empty')
  }
  showNotification({
    body: 'Process intialization 🧩',
    subtitle: 'Simple mesures',
  })
  console.log('Simple mesure start...')

  const {
    command,
    logStream,
    nodeDir,
    workDir: _workDir,
  } = await prepareJsonCollect()
  logStream.write('Simple mesure start...\n')
  console.log(`Urls list: ${JSON.stringify(urlsList)}`)
  logStream.write(`Urls list: ${urlsList}`)
  try {
    urlsList.forEach(url => {
      if (url.value) {
        command.push('-u')
        command.push(url.value)
      }
    })
    command.push('-o')
    command.push('html')
    command.push('--output-path')
    command.push(_workDir)
    // Fake mesure and path. TODO: use specified path and urls
    showNotification({
      body: 'Mesures started 🚀',
      subtitle: 'Simple mesures',
    })
    try {
      await runJsonCollect(command, nodeDir, event, logStream)
    } catch (error) {
      throw new Error('Simple collect error')
    }
    // process.stdout.write(data)
    // console.log(result.stdout.toString());
    showNotification({
      body: `Mesures done, you can consult reports in\n${_workDir}`,
      subtitle: 'Simple mesures',
    })
    console.log('Simple mesure done 🚀')
    return 'mesure done'
  } catch (error) {
    logStream.write(`stderr: ${error}\n`)
  }
  // alert process done
}

const handleJsonSaveAndCollect = async (
  event: IpcMainEvent,
  jsonDatas: IJsonMesureData,
  andCollect: boolean,
) => {
  if (!jsonDatas) {
    throw new Error('Json data is empty')
  }
  // console.log(`Json data: ${JSON.stringify(jsonDatas)}`)

  showNotification({
    body: 'Process intialization 🧩',
    subtitle: 'Json save handler',
  })
  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    console.log(`Work dir: ${_workDir}`)
    const jsonFilePath = `${_workDir}/${utils.JSON_FILE_NAME}`
    const jsonStream = fs.createWriteStream(jsonFilePath)
    if (jsonDatas['extra-header']) {
      try {
        jsonDatas['extra-header'] = JSON.parse(
          Object(jsonDatas['extra-header']),
        )
        String(jsonDatas['extra-header']).replace(/\\/g, '')
      } catch (error) {
        console.error(`extra-header is not in Json format.`, error)
        jsonDatas['extra-header'] = {}
      }
    }
    jsonStream.write(JSON.stringify(jsonDatas, null, 2))
    showNotification({
      body: 'Json file saved 📁',
      subtitle: 'Json save handler',
    })
    if (andCollect) {
      showNotification({
        body: 'Process intialization 🧩',
        subtitle: 'Json mesures handler',
      })
      console.log('Json mesure start...')

      const {
        command,
        logStream,
        nodeDir,
        workDir: _workDir,
      } = await prepareJsonCollect()
      logStream.write('Json mesure start...\n')
      logStream.write(`JSON datas ${JSON.stringify(jsonDatas, null, 2)}\n`)
      command.push('--json-file')
      command.push(_workDir + '/' + utils.JSON_FILE_NAME)
      console.log(command)
      try {
        await runJsonCollect(command, nodeDir, event, logStream)
      } catch (error) {
        throw new Error('Simple collect error')
      }
      showNotification({
        body: `Mesures done, you can consult reports in\n${_workDir}`,
        subtitle: 'Json mesures',
      })
      console.log('Json mesure done 🚀')
      return 'mesure done'
    }
  } catch (error) {
    if (!andCollect) {
      _sendMessageToFrontLog('ERROR', 'Json file not saved', error)
      showNotification({
        body: 'Json file not saved 📁',
        subtitle: 'Json save handler',
      })
    } else {
      showNotification({
        body: 'Json file not saved or collect 📁',
        subtitle: 'Json save and collect handler',
      })
    }
  }
}

const handleJsonReadAndReload = async (event: IpcMainEvent) => {
  showNotification({
    body: 'Process intialization 🧩',
    subtitle: 'Json read and reload handler',
  })
  try {
    const _workDir = await workDir
    if (!_workDir || _workDir === '') {
      throw new Error('Work dir not found')
    }
    console.log(`Work dir: ${_workDir}`)
    const jsonFilePath = `${_workDir}/${utils.JSON_FILE_NAME}`
    return new Promise((resolve, reject) => {
      const jsonStream = fs.createReadStream(jsonFilePath)
      jsonStream.on('data', function (chunk) {
        const jsonDatas = JSON.parse(chunk.toString())
        // console.log(`jsonDatas`, jsonDatas)

        showNotification({
          body: 'Json file read and reloaded 📁',
          subtitle: 'Json read and reload handler',
        })
        resolve(jsonDatas as IJsonMesureData)
      })
    })
  } catch (error) {
    _sendMessageToFrontLog('ERROR', 'Json file not read and reloaded', error)
    showNotification({
      body: 'Json file not read and reloaded 📁',
      subtitle: 'Json read and reload handler',
    })
  }
}

async function handleSelectFolder() {
  const options: Electron.OpenDialogOptions = {
    properties: ['openDirectory', 'createDirectory'],
  }
  const { canceled, filePaths } = await dialog.showOpenDialog(options)
  if (!canceled) {
    workDir = filePaths[0]
    return filePaths[0]
  }
}

async function getNodeVersion() {
  return await _getNodeVersion()
}

function showNotification(options: any) {
  if (!options) {
    options = {
      body: 'Notification body',
      subtitle: 'Notification subtitle',
    }
  }
  if (!options.title || options.title === '') {
    options.title = packageJson.productName
  }
  const customNotification = new Notification(options)
  customNotification.show()
}

// #endregion
